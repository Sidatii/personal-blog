---
phase: 01-core-publishing
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified: []
autonomous: true
must_haves:
  truths:
    - "Posts can be created from markdown files in content/posts/"
    - "Post metadata (title, slug, category, tags) is queryable via PostgreSQL"
    - "Markdown rendering strips unsafe HTML and blocks javascript: links"
    - "Content changes are detectable via content_hash"
    - "Repository pattern is established for data access"
  artifacts:
    - path: "database/migrations/*_create_posts_table.php"
      provides: "Posts schema with slug, content_hash, timestamps"
    - path: "database/migrations/*_create_categories_table.php"
      provides: "Categories schema with slug, post_count"
    - path: "database/migrations/*_create_tags_table.php"
      provides: "Tags schema with slug, post_count"
    - path: "database/migrations/*_create_post_tag_table.php"
      provides: "Many-to-many relationship between posts and tags"
    - path: "app/Models/Post.php"
      provides: "Post Eloquent model with relationships"
    - path: "app/Models/Category.php"
      provides: "Category Eloquent model with posts relationship"
    - path: "app/Models/Tag.php"
      provides: "Tag Eloquent model with posts relationship"
    - path: "app/Repositories/Contracts/PostRepositoryInterface.php"
      provides: "Repository contract for posts"
    - path: "app/Repositories/Contracts/CategoryRepositoryInterface.php"
      provides: "Repository contract for categories"
    - path: "app/Repositories/Eloquent/PostRepository.php"
      provides: "Eloquent implementation for posts"
    - path: "app/Repositories/Eloquent/CategoryRepository.php"
      provides: "Eloquent implementation for categories"
    - path: "app/Services/Content/MarkdownParser.php"
      provides: "Secure markdown parsing service"
    - path: "app/Services/Content/ContentIndexer.php"
      provides: "Content indexing service"
    - path: "app/Console/Commands/SyncContentCommand.php"
      provides: "Manual content sync command"
    - path: "content/posts/"
      provides: "Content directory for markdown files"
  key_links:
    - from: "app/Models/Post.php"
      to: "app/Models/Category.php"
      via: "category_id foreign key relationship"
      pattern: "belongsTo\\(Category::class\\)"
    - from: "app/Models/Post.php"
      to: "app/Models/Tag.php"
      via: "post_tag pivot table"
      pattern: "belongsToMany\\(Tag::class\\)"
    - from: "app/Services/Content/ContentIndexer.php"
      to: "app/Services/Content/MarkdownParser.php"
      via: "Dependency injection"
      pattern: "inject.*MarkdownParser"
    - from: "app/Console/Commands/SyncContentCommand.php"
      to: "app/Services/Content/ContentIndexer.php"
      via: "Method call"
      pattern: "\\$this->call\\(ContentIndexer::class"
---

<objective>
Create the core publishing foundation for the personal blog: database schema, Eloquent models, repository layer, markdown parser with security configuration, and content indexing service.

Purpose: Establish the data layer and content pipeline that all subsequent phases depend on. This foundation must be secure-by-design (markdown XSS prevention), performance-optimized (eager loading, proper indexing), and follow Laravel conventions (repository pattern, service layer).

Output: Working content pipeline where `php artisan content:sync` reads markdown files from `content/posts/` and creates Post records in the database with proper relationships.
</objective>

<execution_context>
@/home/human/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/human/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/research/SUMMARY.md

# Research Insights for Phase 1

## Critical Security Configuration
Markdown parser MUST be configured with:
- `'html_input' => 'strip'` — Strips ALL HTML from markdown, prevents XSS
- `'allow_unsafe_links' => false` — Blocks javascript:, data: URLs

## Critical Performance Patterns
- Always use `->with(['category', 'tags'])` to prevent N+1 queries
- Index content_hash for change detection (MD5 of file content)
- Use slug for pretty URLs, not ID

## Architecture Pattern
Service-repository pattern:
- Models: Data shape and relationships
- Repositories: Data access logic (interface → implementation)
- Services: Business logic (markdown parsing, content indexing)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migrations for posts, categories, tags</name>
  <files>database/migrations/*_create_posts_table.php, database/migrations/*_create_categories_table.php, database/migrations/*_create_tags_table.php, database/migrations/*_create_post_tag_table.php</files>
  <action>
    Create four migration files in `database/migrations/`:

    **Posts table migration** with:
    - `id` (bigIncrements) — Primary key
    - `slug` (string, unique) — For pretty URLs (/blog/my-post-title)
    - `title` (string) — Post title
    - `excerpt` (text, nullable) — SEO description, optional
    - `filepath` (string) — Path to source markdown file
    - `content_hash` (string) — MD5 hash of file content for change detection
    - `category_id` (unsignedBigInteger, nullable, constrained, nullOnDelete) — Optional category
    - `published_at` (timestamp, nullable) — Null = draft, set = published
    - `is_featured` (boolean, default false) — Feature flag for homepage
    - `view_count`, `comment_count`, `reaction_count` (unsignedInteger, default 0) — Analytics counters
    - `timestamps` + `softDeletes` — Standard Laravel timestamps
    - Indexes: `['published_at', 'is_featured']` compound index for queries, `content_hash` index for change detection

    **Categories table migration** with:
    - `id` (bigIncrements)
    - `name` (string) — Display name
    - `slug` (string, unique) — URL-friendly identifier
    - `description` (text, nullable) — Category description
    - `post_count` (unsignedInteger, default 0) — Denormalized counter for performance
    - `timestamps`

    **Tags table migration** with:
    - `id` (bigIncrements)
    - `name` (string) — Display name
    - `slug` (string, unique) — URL-friendly identifier
    - `post_count` (unsignedInteger, default 0) — Denormalized counter
    - `timestamps`

    **Post-tag pivot table migration** with:
    - `post_id` (unsignedBigInteger, constrained, onDelete('cascade'))
    - `tag_id` (unsignedBigInteger, constrained, onDelete('cascade'))
    - Primary key: `['post_id', 'tag_id']` — Composite primary for uniqueness

    **Migration naming convention:** Use current timestamp format (YYYY_MM_DD_HHMMSS_create_posts_table.php)
  </action>
  <verify>
    Run `php artisan migrate:fresh --path=database/migrations/` and verify tables exist:
    ```bash
    php artisan migrate:fresh --path=database/migrations/
    php artisan tinker --execute="Schema::hasTable('posts')"  # Should return true
    php artisan tinker --execute="Schema::hasTable('categories')"  # Should return true
    php artisan tinker --execute="Schema::hasTable('tags')"  # Should return true
    php artisan tinker --execute="Schema::hasTable('post_tag')"  # Should return true
    ```
  </verify>
  <done>
    All four migration files exist and create tables with correct schema, indexes, and foreign key constraints when migrated
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Eloquent models for Post, Category, Tag</name>
  <files>app/Models/Post.php, app/Models/Category.php, app/Models/Tag.php</files>
  <action>
    Create three Eloquent model files:

    **Post model** (`app/Models/Post.php`) with:
    - `$fillable`: `['slug', 'title', 'excerpt', 'filepath', 'content_hash', 'category_id', 'published_at', 'is_featured']`
    - `$casts`: `['published_at' => 'datetime', 'is_featured' => 'boolean']`
    - Relationships:
      - `category()`: `return $this->belongsTo(Category::class);` — Single category
      - `tags()`: `return $this->belongsToMany(Tag::class)->withTimestamps();` — Many tags with pivot timestamps
      - `comments()`: `return $this->hasMany(Comment::class);` — For Phase 5 (return empty for now)
      - `reactions()`: `return $this->hasMany(Reaction::class);` — For Phase 5 (return empty for now)
    - Scopes:
      - `published()`: `return $this->whereNotNull('published_at');` — Only published posts
      - `featured()`: `return $this->where('is_featured', true);` — Featured posts only
      - `recent($limit = 10)`: `return $this->orderBy('published_at', 'desc')->limit($limit);` — Recent posts

    **Category model** (`app/Models/Category.php`) with:
    - `$fillable`: `['name', 'slug', 'description', 'post_count']`
    - Relationship: `posts()`: `return $this->hasMany(Post::class);` — Posts in this category

    **Tag model** (`app/Models/Tag.php`) with:
    - `$fillable`: `['name', 'slug', 'post_count']`
    - Relationship: `posts()`: `return $this->belongsToMany(Post::class)->withTimestamps();` — Posts with this tag
  </action>
  <verify>
    Run Laravel tinker to verify models and relationships:
    ```bash
    php artisan tinker
    # Verify models exist
    Post::factory()->create(['title' => 'Test Post']);
    Category::factory()->create(['name' => 'Tech']);
    Tag::factory()->create(['name' => 'laravel']);

    # Verify relationships work
    $post = Post::first();
    $post->category;  // Should return category or null
    $post->tags;  // Should return collection

    $category = Category::first();
    $category->posts;  // Should return posts collection
    ```
  </verify>
  <done>
    All three models exist with correct fillable, casts, relationships, and scopes that work in tinker
  </done>
</task>

<task type="auto">
  <name>Task 3: Create repository interfaces</name>
  <files>app/Repositories/Contracts/PostRepositoryInterface.php, app/Repositories/Contracts/CategoryRepositoryInterface.php</files>
  <action>
    Create repository contract interfaces:

    **PostRepositoryInterface** (`app/Repositories/Contracts/PostRepositoryInterface.php`) with methods:
    - `findPublishedBySlug(string $slug): ?Post` — Find published post by slug
    - `findPublished(int $limit = 10): Collection` — Get published posts with pagination
    - `findByCategory(Category $category, int $limit = 10): Collection` — Posts in category
    - `findByTag(Tag $tag, int $limit = 10): Collection` — Posts with tag
    - `findFeatured(int $limit = 5): Collection` — Featured posts
    - `updateOrCreateFromIndex(array $data): Post` — Upsert from content indexer
    - `markAsChanged(string $filepath): void` — Mark file as needing reindex
    - `allPublished(): Collection` — All published posts

    **CategoryRepositoryInterface** (`app/Repositories/Contracts/CategoryRepositoryInterface.php`) with methods:
    - `findBySlug(string $slug): ?Category` — Find category by slug
    - `all(): Collection` — All categories
    - `findOrCreate(string $name, string $slug): Category` — Find or create category
    - `withPostCount(): Collection` — Categories with post count populated

    Place interfaces in `app/Repositories/Contracts/` directory
  </action>
  <verify>
    Verify interfaces can be resolved from Laravel container:
    ```bash
    php artisan tinker
    app(PostRepositoryInterface::class);  # Should resolve without error
    app(CategoryRepositoryInterface::class);  # Should resolve without error
    ```
  </verify>
  <done>
    Repository interfaces define the contract for data access operations
  </done>
</task>

</tasks>

<verification>
## Phase 1 Verification Checklist

Run these commands to verify Phase 1 completion:

```bash
# 1. Database migrations
php artisan migrate:fresh --path=database/migrations/
php artisan tinker --execute="echo 'Tables: ' . \DB::table('information_schema.tables')->where('table_schema', 'public')->count() . ' tables created';"

# 2. Models exist and relationships work
php artisan tinker --execute="Post::factory()->create(['title' => 'Test']);"
php artisan tinker --execute="Category::factory()->create(['name' => 'Tech']);"
php artisan tinker --execute="Tag::factory()->create(['name' => 'php']);"

# 3. Markdown parser strips unsafe HTML
php artisan tinker --execute='$parser = app(\App\Services\Content\MarkdownParser::class); $result = $parser->parse("<script>alert(1)</script> [link](javascript:alert(1))"); echo str_contains($result["body"], "<script>") ? "FAIL: XSS" : "PASS: No XSS";'

# 4. Content sync command exists
php artisan content:sync --help  # Should show command signature

# 5. Create test content and sync
echo -e "---\ntitle: Test Post\ncategory: Tech\n---\n\nHello **world**" > content/posts/test.md
php artisan content:sync
php artisan tinker --execute="echo \App\Models\Post::first()->title;"
```
</verification>

<success_criteria>
## Phase 1 Success Criteria

**Functional:**
- [ ] `php artisan migrate:fresh --path=database/migrations/` creates posts, categories, tags, post_tag tables
- [ ] `Post::published()->with(['category', 'tags'])->get()` returns no N+1 queries
- [ ] `MarkdownParser` strips `<script>` tags and blocks `javascript:` links
- [ ] `php artisan content:sync` creates Post records from markdown files
- [ ] Posts have correct relationships (category, tags)

**Quality:**
- [ ] All code follows Laravel conventions (PSR-12, Laravel style guide)
- [ ] No hardcoded strings (use config files)
- [ ] Security-first markdown configuration (html_input: strip, allow_unsafe_links: false)
- [ ] Repository pattern established with interfaces
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-publishing/01-01-SUMMARY.md`
</output>
