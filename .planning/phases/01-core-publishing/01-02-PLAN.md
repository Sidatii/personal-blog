---
phase: 01-core-publishing
plan: "02"
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: []
autonomous: true
must_haves:
  truths:
    - "Post data access is abstracted behind repository interfaces"
    - "Category and tag data access is abstracted behind repository interfaces"
    - "Markdown parser strips unsafe HTML and parses frontmatter correctly"
  artifacts:
    - path: "app/Repositories/Eloquent/PostRepository.php"
      provides: "Eloquent implementation of PostRepositoryInterface"
    - path: "app/Repositories/Eloquent/CategoryRepository.php"
      provides: "Eloquent implementation of CategoryRepositoryInterface"
    - path: "app/Repositories/Eloquent/TagRepository.php"
      provides: "Eloquent implementation for tags"
    - path: "app/Services/Content/MarkdownParser.php"
      provides: "Secure markdown parsing with frontmatter extraction"
  key_links:
    - from: "app/Repositories/Eloquent/PostRepository.php"
      to: "app/Repositories/Contracts/PostRepositoryInterface.php"
      via: "implements interface"
      pattern: "implements PostRepositoryInterface"
    - from: "app/Repositories/Eloquent/PostRepository.php"
      to: "app/Models/Post.php"
      via: "Constructor injection"
      pattern: "inject.*Post"
    - from: "app/Services/Content/ContentIndexer.php"
      to: "app/Services/Content/MarkdownParser.php"
      via: "Dependency injection"
      pattern: "inject.*MarkdownParser"
---

<objective>
Implement the repository layer with Eloquent implementations and create the markdown parser service with security-first configuration.

Purpose: Complete the service-repository architecture pattern. Repositories abstract data access, making the application testable and flexible. The markdown parser must be secure-by-design to prevent XSS attacks.

Output: Working repository implementations and secure markdown parser that can be used by the content indexer.
</objective>

<execution_context>
@/home/human/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/human/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/research/SUMMARY.md
@.planning/phases/01-core-publishing/01-01-PLAN.md

# Critical from Phase 1 Plan

## Security Configuration (MANDATORY)
Markdown parser MUST have:
```php
$config = [
    'html_input' => 'strip',           // Strip ALL HTML from markdown
    'allow_unsafe_links' => false,    // Block javascript:, data: URLs
    'max_nesting_level' => 100,       // Prevent catastrophic backtracking
    'enable_strong' => true,
    'enable_emphasis' => true,
];
```

## Repository Pattern
- Constructor inject the model (dependency injection)
- Implement ALL methods from the interface
- Use `->with(['category', 'tags'])` to prevent N+1 queries
- Use `updateOrCreate(['filepath' => ...])` for upsert logic
</context>

<tasks>

<task type="auto">
  <name>Task 4: Implement repository layer with Eloquent</name>
  <files>app/Repositories/Eloquent/PostRepository.php, app/Repositories/Eloquent/CategoryRepository.php, app/Repositories/Eloquent/TagRepository.php</files>
  <action>
    Create repository implementation classes:

    **PostRepository** (`app/Repositories/Eloquent/PostRepository.php`) implementing PostRepositoryInterface:
    - Constructor: `public function __construct(Post $post)` — Inject Post model
    - `findPublishedBySlug(string $slug): ?Post` — `return $this->post->published()->where('slug', $slug)->with(['category', 'tags'])->first();`
    - `findPublished(int $limit = 10): Collection` — `return $this->post->published()->with(['category', 'tags'])->limit($limit)->get();`
    - `findByCategory(Category $category, int $limit = 10): Collection` — Use `where('category_id', $category->id)`
    - `findByTag(Tag $tag, int $limit = 10): Collection` — Use `whereHas('tags', ...)`
    - `findFeatured(int $limit = 5): Collection` — `return $this->post->published()->featured()->with(['category', 'tags'])->limit($limit)->get();`
    - `updateOrCreateFromIndex(array $data): Post` — Use `updateOrCreate(['filepath' => $data['filepath']], $data);`
    - `markAsChanged(string $filepath): void` — Update `content_hash` to trigger reindex
    - `allPublished(): Collection` — `return $this->post->published()->with(['category', 'tags'])->get();`

    **CategoryRepository** (`app/Repositories/Eloquent/CategoryRepository.php`) implementing CategoryRepositoryInterface:
    - Constructor: `public function __construct(Category $category)` — Inject Category model
    - `findBySlug(string $slug): ?Category` — `return $this->category->where('slug', $slug)->first();`
    - `all(): Collection` — `return $this->category->all();`
    - `findOrCreate(string $name, string $slug): Category` — Find or create: `return $this->category->firstOrCreate(['slug' => $slug], ['name' => $name]);`
    - `withPostCount(): Collection` — Load post count for each category

    **TagRepository** (`app/Repositories/Eloquent/TagRepository.php`) (standalone, no interface needed yet):
    - Constructor: `public function __construct(Tag $tag)` — Inject Tag model
    - `findOrCreate(string $name, string $slug): Tag` — Similar to CategoryRepository
    - `syncToPost(Post $post, array $tagIds): void` — Sync tags to post via pivot table
  </action>
  <verify>
    Run repository tests:
    ```bash
    php artisan test --filter=PostRepositoryTest
    php artisan test --filter=CategoryRepositoryTest

    # Manual verification
    php artisan tinker
    $repo = app(PostRepositoryInterface::class);
    $posts = $repo->findPublished(5);
    echo $posts->count() . " posts found";
    ```
  </verify>
  <done>
    Repository implementations exist, implement their interfaces, and correctly query the database with eager loading
  </done>
</task>

<task type="auto">
  <name>Task 5: Create markdown parser service with security configuration</name>
  <files>app/Services/Content/MarkdownParser.php</files>
  <action>
    Create MarkdownParser service (`app/Services/Content/MarkdownParser.php`):

    **Constructor** with dependency injection:
    ```php
    public function __construct(CommonMarkConverter $converter)
    {
        $this->converter = $converter;
    }
    ```

    **Security-hardened configuration** (from research):
    ```php
    // In service provider or config
    $config = [
        'html_input' => 'strip',           // CRITICAL: Strips ALL HTML
        'allow_unsafe_links' => false,      // CRITICAL: Blocks javascript:, data:
        'max_nesting_level' => 100,         // Prevents catastrophic backtracking
        'enable_strong' => true,
        'enable_emphasis' => true,
        'disallowed_tags' => ['script', 'iframe', 'object', 'embed'], // Extra protection
    ];
    ```

    **Methods**:
    - `parse(string $markdown): array` — Returns `['body' => HTML string, 'matter' => array]`
    - `extractFrontMatter(string $markdown): array` — Parses YAML frontmatter using `spatie/yaml-front-matter`
    - `convertToHtml(string $markdown): string` — Converts markdown to HTML with security config
    - `parseFile(string $filepath): array` — Reads file and calls parse()

    **Frontmatter parsing**:
    - Use `spatie/yaml-front-matter` package
    - Extract `title`, `category`, `tags`, `excerpt`, `published_at`, `is_featured` from frontmatter
    - Return as associative array

    **Install package**:
    ```bash
    composer require league/commonmark spatie/yaml-front-matter
    ```
  </action>
  <verify>
    Test markdown parser security and functionality:
    ```bash
    php artisan tinker
    $parser = app(MarkdownParser::class);

    # Test 1: XSS prevention
    $result = $parser->parse('<script>alert("xss")</script> **bold**');
    echo str_contains($result['body'], '<script>') ? "FAIL: XSS allowed" : "PASS: No script tag";

    # Test 2: Unsafe link blocking
    $result = $parser->parse('[link](javascript:alert(1))');
    echo str_contains($result['body'], 'javascript:') ? "FAIL: Unsafe link" : "PASS: No javascript link";

    # Test 3: Frontmatter parsing
    $result = $parser->parse("---\ntitle: Test\ncategory: Tech\n---\n\nContent");
    echo $result['matter']['title'] === 'Test' ? "PASS: Frontmatter" : "FAIL: Frontmatter";
    ```
  </verify>
  <done>
    Markdown parser strips unsafe HTML, blocks javascript: links, and correctly parses frontmatter
  </done>
</task>

</tasks>

<verification>
## Phase 1 Plan 2 Verification

```bash
# 1. Test repositories
php artisan tinker
$postRepo = app(PostRepositoryInterface::class);
$posts = $postRepo->findPublished(5);
echo $posts->count() . " posts retrieved with eager loading";

# 2. Test markdown parser security
php artisan tinker --execute='$parser = app(\App\Services\Content\MarkdownParser::class); $r = $parser->parse("<script>alert(1)</script>"); echo str_contains($r["body"], "<script>") ? "XSS FAIL" : "XSS PASS";'
php artisan tinker --execute='$parser = app(\App\Services\Content\MarkdownParser::class); $r = $parser->parse("[link](javascript:alert(1))"); echo str_contains($r["body"], "javascript:") ? "LINK FAIL" : "LINK PASS";'

# 3. Test frontmatter parsing
php artisan tinker --execute='$parser = app(\App\Services\Content\MarkdownParser::class); $r = $parser->parse("---\ntitle: Hello\ncategory: Tech\n---\n\nContent"); echo $r["matter"]["title"] === "Hello" ? "FRONTMATTER PASS" : "FRONTMATTER FAIL";'
```
</verification>

<success_criteria>
## Plan 2 Success Criteria

- [ ] Repositories implement interfaces with Eloquent queries
- [ ] `->with(['category', 'tags'])` prevents N+1 queries
- [ ] Markdown parser strips `<script>` tags
- [ ] Markdown parser blocks `javascript:` links
- [ ] Frontmatter parsing extracts title, category, tags correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-publishing/01-02-SUMMARY.md`
</output>
