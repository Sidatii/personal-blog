---
phase: 02-git-integration-and-deployment
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - routes/web.php
  - deploy.php
  - composer.json
autonomous: true

must_haves:
  truths:
    - "Health check endpoint returns JSON with database, cache, and queue status"
    - "Healthy application returns 200, degraded returns 503"
    - "Deployer script can run deploy command targeting production host"
    - "Deployer config includes shared directories for storage and content-repo"
    - "Queue workers are restarted after deployment via artisan:queue:restart"
  artifacts:
    - path: "routes/web.php"
      provides: "GET /health endpoint"
      contains: "/health"
    - path: "deploy.php"
      provides: "Deployer configuration with Laravel recipe"
      contains: "recipe/laravel"
  key_links:
    - from: "deploy.php"
      to: "artisan:queue:restart"
      via: "Deployer after hook on deploy:symlink"
      pattern: "queue:restart"
    - from: "deploy.php"
      to: "routes/web.php"
      via: "health:check task curls /health endpoint"
      pattern: "health.*check"
    - from: "routes/web.php"
      to: "Illuminate\\Support\\Facades\\DB"
      via: "health endpoint checks DB connection"
      pattern: "DB::connection"
---

<objective>
Create the application health check endpoint and Deployer configuration for zero-downtime deployments. The health endpoint verifies database, cache, and queue connectivity. The Deployer config uses atomic symlink swaps with automatic rollback on health check failure.

Purpose: Production infrastructure for reliable deployments. The health endpoint is used by Deployer post-deployment to verify the application is functional, triggering automatic rollback if checks fail. This is the deployment safety net.

Output: A GET /health endpoint returning component status as JSON, and a deploy.php Deployer configuration ready for production use (host details to be configured per environment).
</objective>

<execution_context>
@/home/human/.claude/get-shit-done/workflows/execute-plan.md
@/home/human/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-git-integration-and-deployment/02-RESEARCH.md
@.planning/phases/02-git-integration-and-deployment/02-CONTEXT.md
@routes/web.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create health check endpoint</name>
  <files>routes/web.php</files>
  <action>
Read the existing `routes/web.php` and add a health check route. Keep the existing welcome route. Add the health check after it:

```php
Route::get('/health', function () {
    $checks = [
        'database' => false,
        'cache' => false,
        'queue' => false,
    ];

    // Check database connection
    try {
        \Illuminate\Support\Facades\DB::connection()->getPdo();
        $checks['database'] = true;
    } catch (\Throwable $e) {
        // Database unavailable
    }

    // Check cache driver
    try {
        \Illuminate\Support\Facades\Cache::store()->put('health-check', true, 10);
        \Illuminate\Support\Facades\Cache::store()->forget('health-check');
        $checks['cache'] = true;
    } catch (\Throwable $e) {
        // Cache unavailable
    }

    // Check queue table accessible
    try {
        \Illuminate\Support\Facades\DB::table('jobs')->count();
        $checks['queue'] = true;
    } catch (\Throwable $e) {
        // Queue table unavailable
    }

    $healthy = $checks['database'] && $checks['cache'] && $checks['queue'];

    return response()->json([
        'status' => $healthy ? 'ok' : 'degraded',
        'checks' => $checks,
        'timestamp' => now()->toISOString(),
    ], $healthy ? 200 : 503);
})->name('health');
```

Why in web.php (not api.php): The health endpoint is infrastructure, not part of the API. It avoids file conflicts with Plan 02 which creates api.php. Laravel's built-in /up health route is also in web routes.

Why not a controller: This is a simple closure route with no reusable logic. A controller would be over-engineering for a route that just checks three connections.

Why check jobs table directly: Using `DB::table('jobs')->count()` instead of `Queue::size()` because Queue::size() may not work with all drivers in the same way, and we specifically want to verify the jobs table is accessible (the database queue driver is configured).
  </action>
  <verify>
1. Start dev server if not running: `php artisan serve &` (or skip if already running)
2. `curl -s http://localhost:8000/health | python3 -m json.tool` -- should return JSON with status, checks, timestamp
3. `php artisan route:list --name=health` -- should show GET /health route
4. Verify the response includes all three check keys (database, cache, queue)
  </verify>
  <done>GET /health endpoint returns JSON with database, cache, and queue connectivity status. Returns 200 when all healthy, 503 when degraded. Includes ISO timestamp.</done>
</task>

<task type="auto">
  <name>Task 2: Install Deployer and create deployment configuration</name>
  <files>
    deploy.php
    composer.json
  </files>
  <action>
1. **Install Deployer:**
   Run `composer require --dev deployer/deployer` to add Deployer as a dev dependency.

2. **Create deploy.php** in project root:

```php
<?php

namespace Deployer;

require 'recipe/laravel.php';

// Project configuration
set('application', 'personal-blog');
set('repository', env('DEPLOY_REPOSITORY', 'git@github.com:user/personal-blog.git'));
set('keep_releases', 5);
set('git_tty', false);

// PHP binary path (adjust per server)
set('bin/php', 'php');

// Shared files and directories (persist across releases)
add('shared_files', ['.env']);
add('shared_dirs', [
    'storage',
    'storage/app/content-repo',  // Persist git clone across deployments
]);

// Writable directories
add('writable_dirs', [
    'bootstrap/cache',
    'storage',
    'storage/app',
    'storage/framework/cache',
    'storage/framework/sessions',
    'storage/framework/views',
    'storage/logs',
]);

// Production host (configure via environment or edit directly)
host('production')
    ->setHostname(env('DEPLOY_HOST', 'example.com'))
    ->setRemoteUser(env('DEPLOY_USER', 'forge'))
    ->setDeployPath(env('DEPLOY_PATH', '/home/forge/personal-blog'));

// Restart queue workers after symlink swap (new code takes effect)
after('deploy:symlink', 'artisan:queue:restart');

// Unlock deployment on failure
after('deploy:failed', 'deploy:unlock');

// Custom health check task
task('health:check', function () {
    $url = get('health_check_url', 'http://localhost/health');
    $response = run("curl -sf {$url}");
    $data = json_decode($response, true);

    if (!$data || ($data['status'] ?? '') !== 'ok') {
        throw new \RuntimeException(
            'Health check failed: ' . ($response ?: 'no response')
        );
    }

    writeln('<info>Health check passed</info>');
})->desc('Verify application health after deployment');

// Run health check after deployment
after('deploy:symlink', 'health:check');

// Custom task: run content sync after deployment
task('content:sync', function () {
    run('{{bin/php}} {{release_or_current_path}}/artisan content:sync');
})->desc('Sync content from git repository');
```

IMPORTANT notes in the file:
- Host configuration uses placeholder values. User must update DEPLOY_HOST, DEPLOY_USER, and DEPLOY_PATH for their server.
- The `storage/app/content-repo` shared directory ensures the git clone persists across deployments (Pitfall 5 from RESEARCH.md).
- `artisan:queue:restart` runs after symlink swap so workers pick up new code (Pitfall 2 from RESEARCH.md).
- Health check runs after symlink swap and before deployment is considered complete. If it fails, the deployment fails and `deploy:unlock` runs.

3. **Verify Deployer installed:** Run `vendor/bin/dep list` to confirm Deployer CLI works.
  </action>
  <verify>
1. `composer show deployer/deployer` -- confirms package installed
2. `vendor/bin/dep list` -- shows available Deployer commands without error
3. `vendor/bin/dep config:dump` -- shows configuration loads from deploy.php (may show warnings about host config, that's expected with placeholder values)
4. Verify deploy.php contains shared_dirs with content-repo: `grep 'content-repo' deploy.php`
5. Verify queue restart hook: `grep 'queue:restart' deploy.php`
  </verify>
  <done>Deployer 7.x installed as dev dependency. deploy.php configured with Laravel recipe, atomic symlink deployments, 5 release retention, shared storage/content-repo directory, queue:restart after deployment, health check verification, and deploy:unlock on failure. Host config uses placeholders for user to configure.</done>
</task>

</tasks>

<verification>
- GET /health returns JSON with status, checks (database/cache/queue), and timestamp
- Healthy app returns 200, degraded returns 503
- Deployer installed and `vendor/bin/dep list` works
- deploy.php includes shared_dirs with content-repo
- deploy.php hooks: queue:restart after symlink, health:check after symlink, unlock on failure
- No file conflicts with other Wave 1 plans (health in web.php, not api.php)
</verification>

<success_criteria>
- Health endpoint accessible at GET /health with component-level status reporting
- Deployer configuration ready for production deployment (with placeholder host config)
- Atomic symlink deployment with 5-release retention
- Queue workers restarted post-deployment
- Health check gates deployment success (failure = deployment fails)
- Git content-repo persists across deployments via shared directory
</success_criteria>

<output>
After completion, create `.planning/phases/02-git-integration-and-deployment/02-04-SUMMARY.md`
</output>
