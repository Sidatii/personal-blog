---
phase: 06-reader-engagement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - database/migrations/2026_02_08_000001_create_comments_table.php
  - database/migrations/2026_02_08_000002_create_comment_reactions_table.php
  - app/Models/Comment.php
  - app/Models/CommentReaction.php
  - app/Repositories/Contracts/CommentRepositoryInterface.php
  - app/Repositories/Eloquent/CommentRepository.php
  - app/Http/Controllers/CommentController.php
  - app/Http/Requests/StoreCommentRequest.php
  - routes/web.php
  - config/comments.php
autonomous: true

must_haves:
  truths:
    - Readers can submit comments on blog posts
    - Comments support threaded replies (parent-child relationship)
    - Anonymous commenting is supported with optional name/email fields
    - Submitted comments start in pending status for moderation
    - Comments can be fetched as a thread for display
  artifacts:
    - path: "database/migrations/2026_02_08_000001_create_comments_table.php"
      provides: "Comments database schema with threading support"
      contains: "post_id, parent_id, author fields, content, status, ip_address"
    - path: "app/Models/Comment.php"
      provides: "Comment model with relationships and scopes"
      exports: ["approved scope", "pending scope", "root scope", "replies relationship"]
    - path: "app/Repositories/Eloquent/CommentRepository.php"
      provides: "Comment data access with recursive CTE for threading"
      exports: ["getThreadForPost", "create", "approve", "markAsSpam"]
    - path: "app/Http/Controllers/CommentController.php"
      provides: "Public comment submission and listing endpoints"
      exports: ["index", "store"]
  key_links:
    - from: "CommentController::store"
      to: "CommentRepository::create"
      via: "repository method call"
      pattern: "$this->commentRepository->create(...)"
    - from: "CommentRepository::getThreadForPost"
      to: "PostgreSQL recursive CTE"
      via: "DB::select with WITH RECURSIVE"
      pattern: "WITH RECURSIVE comment_tree"
    - from: "routes/web.php"
      to: "CommentController"
      via: "Route::post('/posts/{post}/comments')"
      pattern: "comments.store"
---

<objective>
Establish the core comments infrastructure including database schema, models, repository pattern implementation, and public API endpoints. This is the foundation for the self-hosted comments system.

Purpose: Enable reader engagement through comments with full data ownership and moderation control.
Output: Working comments database, models, repository layer, and public submission endpoints.
</objective>

<execution_context>
@/home/human/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/human/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-reader-engagement/06-CONTEXT.md
@.planning/phases/06-reader-engagement/06-RESEARCH.md

# Existing patterns to follow
@app/Repositories/Contracts/PostRepositoryInterface.php
@app/Repositories/Eloquent/PostRepository.php
@app/Models/Post.php
@routes/web.php

# Tech stack
- Laravel 12.50.0 with PostgreSQL 18.1 (supports recursive CTEs)
- Repository pattern in app/Repositories/{Contracts,Eloquent}
- Alpine.js 3.x already installed
- Rate limiting via RouteServiceProvider
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comments database schema and models</name>
  <files>
    database/migrations/2026_02_08_000001_create_comments_table.php
    database/migrations/2026_02_08_000002_create_comment_reactions_table.php
    app/Models/Comment.php
    app/Models/CommentReaction.php
    config/comments.php
  </files>
  <action>
    Create two migrations and corresponding models:

    1. **comments table migration:**
       - id (bigIncrements)
       - post_id (foreignId, constrained to posts, cascade delete)
       - parent_id (nullable foreignId to comments, cascade delete)
       - author_name, author_email, author_website (all nullable strings)
       - content (text, required)
       - content_html (nullable text, for pre-rendered markdown)
       - status (string, default 'pending') - pending, approved, spam, rejected
       - is_highlighted (boolean, default false)
       - ip_address (nullable ipAddress)
       - user_agent (nullable text)
       - timestamps
       - Indexes: post_id+status, parent_id, created_at

    2. **comment_reactions table migration:**
       - id (bigIncrements)
       - comment_id (foreignId, constrained, cascade delete)
       - reaction_type (string: like, dislike, laugh, heart, celebrate)
       - ip_address (ipAddress, required)
       - user_agent (nullable text)
       - timestamps
       - Unique: comment_id + reaction_type + ip_address

    3. **Comment model** with:
       - Fillable: post_id, parent_id, author fields, content, status, ip, user_agent
       - Casts: is_highlighted to boolean, status to CommentStatus enum
       - Relationships: post(), parent(), replies(), reactions()
       - Scopes: approved(), pending(), root(), forPost($postId)
       - Accessor: reaction_counts (aggregated by type)
       - Method: getContentHtmlAttribute() - uses CommonMark to parse content if content_html is null

    4. **CommentReaction model** with:
       - Fillable: comment_id, reaction_type, ip_address, user_agent
       - Relationship: comment()

    5. **config/comments.php** with:
       - auto_approve (default: false)
       - max_depth (default: 5)
       - max_length (default: 5000)
       - throttle_per_hour (default: 5)
  </action>
  <verify>
    php artisan migrate --pretend
    php artisan migrate
    php artisan tinker --execute="echo Comment::class; echo CommentReaction::class;"
  </verify>
  <done>
    Migrations run successfully, models load without errors, config file is readable via config('comments.auto_approve')
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Comment repository layer</name>
  <files>
    app/Repositories/Contracts/CommentRepositoryInterface.php
    app/Repositories/Eloquent/CommentRepository.php
    app/Providers/RepositoryServiceProvider.php
  </files>
  <action>
    Implement repository pattern for comments following existing PostRepository pattern:

    1. **CommentRepositoryInterface** with methods:
       - getThreadForPost(Post $post, int $perPage = 50): Collection - returns threaded comments
       - create(array $data, Post $post, ?Comment $parent = null): Comment
       - approve(Comment $comment): bool
       - markAsSpam(Comment $comment): bool
       - markAsRejected(Comment $comment): bool
       - delete(Comment $comment): bool
       - getPendingCount(): int
       - getRecentComments(int $limit = 10, string $status = 'approved'): Collection

    2. **CommentRepository** implementation:
       - Inject Post model via constructor
       - getThreadForPost: Use PostgreSQL recursive CTE (WITH RECURSIVE) to fetch entire thread in one query
         * Limit depth to config('comments.max_depth') to prevent runaway queries
         * Return flat collection with depth field for UI indentation
       - create: Set status based on config('comments.auto_approve'), parse content to HTML using MarkdownParser service
       - approve/markAsSpam/markAsRejected: Update status field
       - Include eager loading for post and reactions relationships

    3. **Register in RepositoryServiceProvider**:
       - Add binding: CommentRepositoryInterface::class => CommentRepository::class

    Follow exact pattern from PostRepository for consistency.
  </action>
  <verify>
    grep -n "CommentRepositoryInterface" app/Providers/RepositoryServiceProvider.php
    php artisan tinker --execute="echo app(CommentRepositoryInterface::class)::class;"
  </verify>
  <done>
    Interface and repository exist, binding is registered in service provider, dependency injection works
  </done>
</task>

<task type="auto">
  <name>Task 3: Create public Comment controller and routes</name>
  <files>
    app/Http/Controllers/CommentController.php
    app/Http/Requests/StoreCommentRequest.php
    routes/web.php
  </files>
  <action>
    Create public-facing comment endpoints:

    1. **StoreCommentRequest** validation:
       - content: required, string, max:5000
       - author_name: nullable, string, max:255
       - author_email: nullable, email, max:255
       - author_website: nullable, url, max:255
       - parent_id: nullable, exists:comments,id
       - honeypot: nullable (for spam detection, will be used in Plan 05)

    2. **CommentController** with:
       - Constructor injection: CommentRepositoryInterface
       - index(Post $post): Display comments for a post (returns JSON or HTML fragment based on request)
       - store(StoreCommentRequest $request, Post $post): Create new comment
         * Check if parent_id is provided and belongs to same post
         * Create via repository
         * Return appropriate response based on request type
       
    3. **Routes in web.php** (after existing post routes):
       - Route::get('/posts/{post}/comments', [CommentController::class, 'index'])->name('comments.index')
       - Route::post('/posts/{post}/comments', [CommentController::class, 'store'])->name('comments.store')->middleware('throttle:comments')

    4. **Rate limiting** in RouteServiceProvider::boot():
       - Add RateLimiter::for('comments', fn($request) => Limit::perHour(config('comments.throttle_per_hour', 5))->by($request->ip()))

    Ensure CSRF protection is in place for POST requests.
  </action>
  <verify>
    php artisan route:list | grep comments
    grep -n "RateLimiter::for('comments'" app/Providers/RouteServiceProvider.php
  </verify>
  <done>
    Routes registered, controller methods exist, rate limiting configured, validation rules defined
  </done>
</task>

</tasks>

<verification>
1. Run migrations: php artisan migrate
2. Verify models: php artisan tinker --execute="var_dump(get_class(new App\Models\Comment));"
3. Test repository binding: php artisan tinker --execute="var_dump(app(App\Repositories\Contracts\CommentRepositoryInterface::class)::class);"
4. Check routes: php artisan route:list | grep comment
5. Verify rate limiting: grep "comments" app/Providers/RouteServiceProvider.php
</verification>

<success_criteria>
- Database tables created with proper indexes and foreign keys
- Comment and CommentReaction models with relationships and scopes
- CommentRepository registered and injectable
- Public routes for viewing and submitting comments
- Rate limiting active (5 comments/hour per IP)
</success_criteria>

<output>
After completion, create `.planning/phases/06-reader-engagement/06-01-SUMMARY.md`
</output>
