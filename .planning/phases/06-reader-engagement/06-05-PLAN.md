---
phase: 06-reader-engagement
plan: 05
type: execute
wave: 3
depends_on: [06-01, 06-02]
files_modified:
  - app/Rules/Honeypot.php
  - app/Http/Requests/StoreCommentRequest.php
  - resources/views/comments/_form.blade.php
  - resources/views/comments/_comment.blade.php
  - resources/views/comments/_thread.blade.php
  - resources/views/posts/show.blade.php
  - resources/js/app.js
  - package.json
autonomous: true

must_haves:
  truths:
    - Honeypot field prevents automated spam submissions
    - Comments display with proper threading/nesting
    - Comment form submits without full page reload (HTMX)
    - New comments appear immediately after submission
    - Comment styling matches Rose Pine theme
    - Reply buttons allow nested responses
  artifacts:
    - path: "app/Rules/Honeypot.php"
      provides: "Spam prevention validation rule"
      exports: ["validate()"]
    - path: "resources/views/comments/_form.blade.php"
      provides: "Comment submission form with honeypot and HTMX"
      contains: "Honeypot field, HTMX attributes, CSRF token"
    - path: "resources/views/comments/_comment.blade.php"
      provides: "Single comment display partial"
      contains: "Author, content, metadata, reply button, reactions"
    - path: "resources/views/comments/_thread.blade.php"
      provides: "Recursive comment thread rendering"
      contains: "Recursive @include with depth limit"
  key_links:
    - from: "StoreCommentRequest"
      to: "Honeypot rule"
      via: "validation rule in rules array"
      pattern: "'honeypot' => ['nullable', new Honeypot]"
    - from: "Comment form"
      to: "CommentController::store"
      via: "HTMX POST request"
      pattern: "hx-post, hx-target, hx-swap attributes"
    - from: "posts/show.blade.php"
      to: "comments thread"
      via: "@include('comments._thread')"
      pattern: "Comment section at bottom of post"
---

<objective>
Complete the comments system with spam protection, HTMX-powered real-time updates, and polished frontend display. Includes honeypot validation, threaded comment views, and seamless user experience.

Purpose: Deliver a production-ready comment system that's secure, fast, and visually cohesive with the blog design.
Output: Fully functional comment section with spam protection, real-time updates, and proper threading.
</objective>

<execution_context>
@/home/human/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/human/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-reader-engagement/06-01-SUMMARY.md
@.planning/phases/06-reader-engagement/06-02-SUMMARY.md
@.planning/phases/06-reader-engagement/06-RESEARCH.md

# Dependencies
- Plan 06-01 complete (Comment model, controller, database)
- Plan 06-02 complete (Reactions trait, reaction-bar component)
- Alpine.js already installed

# Existing patterns
@app/Http/Requests/StoreProjectRequest.php
@resources/views/posts/show.blade.php
@resources/views/components/reaction-bar.blade.php
@resources/js/app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement honeypot spam protection and enhanced validation</name>
  <files>
    app/Rules/Honeypot.php
    app/Http/Requests/StoreCommentRequest.php
    app/Http/Controllers/CommentController.php
  </files>
  <action>
    Add honeypot spam prevention and enhance comment validation:

    1. **Create Honeypot rule** (app/Rules/Honeypot.php):
       - Implements ValidationRule interface
       - validate() method: If value is not empty, fail with 'Spam detected.'
       - This catches bots that fill out all form fields including hidden ones

    2. **Update StoreCommentRequest**:
       - Add to rules array:
         * 'website' => ['nullable', 'string', 'max:255'] (honeypot field - bots often fill "website")
         * 'trap_field' => ['nullable', new Honeypot] (actual honeypot - should be empty)
       - Make author fields required if content looks like spam (optional enhancement)
       - Customize error messages:
         * 'website.required' => 'Spam detected.'
         * Keep generic messages to not tip off bot operators

    3. **Update CommentController::store**:
       - Validate honeypot field passes (automated via FormRequest)
       - Before creating, check rate limit manually if needed:
         * Optional: Add additional IP-based check beyond Laravel throttle
       - If validation passes honeypot, proceed with normal creation
       - Return appropriate response for HTMX (see Task 2)

    4. **Add CSS for honeypot field** (in _form.blade.php):
       - The honeypot field should be visually hidden:
       ```html
       <div style="position: absolute; left: -9999px;" aria-hidden="true">
           <input type="text" name="trap_field" tabindex="-1" autocomplete="off">
       </div>
       ```
       - Position absolute + negative left keeps it out of viewport
       - tabindex=-1 prevents keyboard navigation
       - autocomplete=off prevents browser autofill
       - aria-hidden=true hides from screen readers

    This multi-layer approach (honeypot + rate limiting from 06-01) provides solid spam protection without CAPTCHA friction.
  </action>
  <verify>
    php artisan tinker --execute="echo App\Rules\Honeypot::class;"
    grep -n "Honeypot" app/Http/Requests/StoreCommentRequest.php
    grep -n "trap_field" app/Http/Requests/StoreCommentRequest.php
  </verify>
  <done>
    Honeypot rule created, added to StoreCommentRequest, honeypot field styled as hidden
  </done>
</task>

<task type="auto">
  <name>Task 2: Install HTMX and update comment controller for real-time updates</name>
  <files>
    package.json
    resources/js/app.js
    app/Http/Controllers/CommentController.php
    resources/views/comments/_form.blade.php
  </files>
  <action>
    Add HTMX for real-time comment updates without page reload:

    1. **Install HTMX**:
       - npm install htmx.org
       - Or use CDN: <script src="https://unpkg.com/htmx.org@1.9.12"></script>

    2. **Initialize HTMX** (resources/js/app.js):
       - Add: import 'htmx.org';
       - Or if using Vite: window.htmx = require('htmx.org');
       - HTMX auto-initializes on DOM ready

    3. **Update CommentController** to support HTMX:
       - index(Post $post) method:
         * Return HTML fragment if request()->header('HX-Request')
         * Return full view otherwise
       
       - store(Request $request, Post $post) method:
         * Create comment via repository (as before)
         * If $request->header('HX-Request'):
           - Return view('comments._comment', ['comment' => $comment, 'depth' => 0])
           - Set HX-Trigger header: 'comment-posted' (for JS notifications)
         * Else:
           - Redirect back with success message (non-HTMX fallback)
       
       - Add error handling for HTMX:
         * Validation errors: Return 422 with error HTML
         * Rate limit: Return 429 with "Too many comments" message

    4. **Create HTMX-powered comment form** (resources/views/comments/_form.blade.php):
       Props: ['post' => null, 'parentId' => null]
       
       Form attributes:
       - hx-post="{{ route('comments.store', $post) }}"
       - hx-target="#comments-list"
       - hx-swap="afterbegin" (newest first)
       - hx-indicator="#comment-submit-spinner"
       
       Fields:
       - Hidden honeypot field (see Task 1)
       - Textarea: name="content", required, rows="4", placeholder
       - Author name: name="author_name", placeholder="Name (optional)"
       - Author email: name="author_email", type="email", placeholder="Email (optional, not published)"
       - @if($parentId) <input type="hidden" name="parent_id" value="{{ $parentId }}"> @endif
       
       Submit section:
       - Submit button: "Post Comment"
       - Loading indicator: #comment-submit-spinner (hidden by default, HTMX shows during request)
       - Helper text: "Comments are moderated before appearing"

    5. **Add success notification area** (in posts/show.blade.php):
       - Empty div with id="comment-success-message" for JS to populate
       - Or use Alpine.js to show toast on HX-Trigger event

    HTMX provides progressive enhancement - form works without JS, works better with JS.
  </action>
  <verify>
    grep -n "htmx" package.json
    grep -n "htmx" resources/js/app.js
    grep -n "HX-Request" app/Http/Controllers/CommentController.php
    ls -la resources/views/comments/_form.blade.php
  </verify>
  <done>
    HTMX installed, CommentController updated for HTMX responses, comment form created with HTMX attributes
  </done>
</task>

<task type="auto">
  <name>Task 3: Create threaded comment views and integrate into post display</name>
  <files>
    resources/views/comments/_comment.blade.php
    resources/views/comments/_thread.blade.php
    resources/views/comments/index.blade.php
    resources/views/posts/show.blade.php
  </files>
  <action>
    Create the complete comment display with threading support:

    1. **Single comment partial** (resources/views/comments/_comment.blade.php):
       Props: ['comment' => null, 'depth' => 0]
       
       Structure:
       - Container div with data-comment-id for targeting
       - Indentation: style="margin-left: {{ $depth * 2 }}rem;" (or Tailwind ml-{{$depth*8}})
       - Border left if depth > 0 for visual threading
       - Author section:
         * Name (bold) or "Anonymous"
         * Gravatar or identicon (optional, based on email hash)
         * Timestamp: {{ $comment->created_at->diffForHumans() }}
       - Content: {{ $comment->content }} (escaped by Blade)
       - Metadata (small, muted text):
         * Reactions count from $comment->reaction_counts (if reactions enabled on comments)
       - Actions row:
         * Reply button: Alpine.js @click to show reply form
         * Reaction bar: <x-reaction-bar :reactable="$comment" /> (if comments are reactable)
       
       Reply form (hidden by default):
       - x-show="showReplyForm" with Alpine.js
       - Includes @include('comments._form', ['parentId' => $comment->id])
       - Cancel button to hide form

    2. **Thread partial** (resources/views/comments/_thread.blade.php):
       Props: ['comments' => [], 'depth' => 0]
       
       Structure:
       - @foreach($comments as $comment)
         * @include('comments._comment', compact('comment', 'depth'))
         * @if($comment->replies && $comment->replies->count() > 0 && $depth < config('comments.max_depth', 5))
             @include('comments._thread', ['comments' => $comment->replies, 'depth' => $depth + 1])
         * @endif
       - @endforeach
       
       This recursive rendering creates the threaded view.

    3. **Comments section container** (resources/views/comments/index.blade.php):
       Props: ['post' => null, 'comments' => []]
       
       Structure:
       - Section wrapper: id="comments-section"
       - Header: "Comments ({{ $comments->count() }})"
       - New comment form: @include('comments._form', ['post' => $post])
       - Comments list: id="comments-list"
         * If no comments: "No comments yet. Be the first to share your thoughts!"
         * @include('comments._thread', ['comments' => $comments])

    4. **Integrate into post view** (resources/views/posts/show.blade.php):
       - Find the end of post content
       - Add: @include('comments.index', compact('post', 'comments'))
       - Ensure $comments is passed from BlogController@show
       - Comments should appear after content and reactions, before footer

    5. **Update BlogController@show** to load comments:
       - Inject CommentRepositoryInterface
       - Add: $comments = $this->commentRepository->getThreadForPost($post);
       - Pass to view: compact('post', 'comments')

    Styling follows Rose Pine theme:
    - Surface backgrounds, subtle borders
    - Foam color for links, Love for important actions
    - Proper spacing and typography
  </action>
  <verify>
    ls -la resources/views/comments/
    grep -n "comments" resources/views/posts/show.blade.php
    grep -n "getThreadForPost" app/Http/Controllers/BlogController.php
  </verify>
  <done>
    _comment.blade.php partial created, _thread.blade.php recursive partial created, comments section integrated in post view, BlogController loads comments
  </done>
</task>

</tasks>

<verification>
1. Verify honeypot: grep -n "trap_field" resources/views/comments/_form.blade.php
2. Check HTMX integration: grep -n "hx-post" resources/views/comments/_form.blade.php
3. Verify comment views: ls -la resources/views/comments/
4. Test recursive template: grep -n "@include('comments._thread')" resources/views/comments/_thread.blade.php
5. Check post view integration: grep -n "comments" resources/views/posts/show.blade.php
</verification>

<success_criteria>
- Honeypot validation rule created and applied
- HTMX installed and integrated for real-time comment submission
- Comment form with honeypot and HTMX attributes
- Comment controller returns HTML fragments for HTMX
- _comment.blade.php partial with threading support
- _thread.blade.php recursive rendering
- Comments displayed on post pages with proper nesting
- Reply functionality with depth limiting
- Rose Pine themed styling
</success_criteria>

<output>
After completion, create `.planning/phases/06-reader-engagement/06-05-SUMMARY.md`
</output>
