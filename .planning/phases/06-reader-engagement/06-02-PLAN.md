---
phase: 06-reader-engagement
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - database/migrations/2026_02_08_000003_create_reactions_table.php
  - app/Models/Reaction.php
  - app/Models/Traits/Reactable.php
  - app/Models/Post.php
  - app/Models/Comment.php
  - app/Http/Controllers/ReactionController.php
  - resources/views/components/reaction-bar.blade.php
  - routes/web.php
autonomous: true

must_haves:
  truths:
    - Visitors can react to posts with multiple emoji types (üëç ‚ù§Ô∏è üéâ üöÄ)
    - Reactions are anonymous (tracked by IP to prevent duplicates)
    - Visitors can toggle reactions on/off (click to add, click again to remove)
    - Reaction counts are publicly visible
    - User's current reactions are indicated visually
  artifacts:
    - path: "database/migrations/2026_02_08_000003_create_reactions_table.php"
      provides: "Polymorphic reactions table"
      contains: "reactable_id, reactable_type, reaction_type, ip_address, unique constraint"
    - path: "app/Models/Traits/Reactable.php"
      provides: "Polymorphic reactions trait"
      exports: ["reactions()", "reaction_counts", "userHasReacted()"]
    - path: "app/Http/Controllers/ReactionController.php"
      provides: "API endpoint for toggling reactions"
      exports: ["store()"]
    - path: "resources/views/components/reaction-bar.blade.php"
      provides: "Interactive reaction UI component"
      contains: "Alpine.js x-data, toggle function, emoji buttons with counts"
  key_links:
    - from: "Post model"
      to: "Reactable trait"
      via: "use Reactable"
      pattern: "class Post extends Model { use Reactable; }"
    - from: "reaction-bar component"
      to: "ReactionController"
      via: "fetch POST /reactions"
      pattern: "x-data toggle() function with fetch API"
    - from: "ReactionController::store"
      to: "Reactable models"
      via: "morphTo relationship"
      pattern: "$reactable->reactions()->createOrDelete()"
---

<objective>
Implement the polymorphic reactions system allowing visitors to react to posts and comments with emoji reactions. Includes database schema, models, controller API, and Alpine.js interactive component.

Purpose: Provide expressive engagement beyond simple likes, supporting üëç ‚ù§Ô∏è üéâ üöÄ reactions with toggle functionality.
Output: Fully working reactions on posts with real-time count updates and duplicate prevention.
</objective>

<execution_context>
@/home/human/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/human/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-reader-engagement/06-01-SUMMARY.md
@.planning/phases/06-reader-engagement/06-RESEARCH.md

# Dependencies
- Plan 06-01 must be complete (Post model exists)
- Alpine.js already installed (from Phase 3)

# Existing patterns
@app/Models/Post.php
@app/Http/Controllers/Controller.php
@resources/views/components/ (for component structure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create polymorphic reactions database and models</name>
  <files>
    database/migrations/2026_02_08_000003_create_reactions_table.php
    app/Models/Reaction.php
    app/Models/Traits/Reactable.php
  </files>
  <action>
    Create the polymorphic reactions system:

    1. **Create reactions table migration:**
       - id (bigIncrements)
       - reactable_id (unsignedBigInteger)
       - reactable_type (string)
       - reaction_type (string) - 'thumbs_up', 'heart', 'celebrate', 'rocket'
       - ip_address (ipAddress, required)
       - user_agent (nullable text)
       - timestamps
       - Composite unique index: [reactable_id, reactable_type, reaction_type, ip_address]
       - Index: [reactable_id, reactable_type] for polymorphic queries
       - Index: reaction_type for aggregation

    2. **Reaction model** with:
       - Fillable: reactable_id, reactable_type, reaction_type, ip_address, user_agent
       - Relationship: reactable() - morphTo()
       - Scope: forReactable($model) - filter by model
       - Scope: ofType($type) - filter by reaction_type

    3. **Reactable trait** (app/Models/Traits/Reactable.php):
       - reactions() method: morphMany(Reaction::class, 'reactable')
       - getReactionCountsAttribute(): Returns array of counts keyed by reaction_type
       - userHasReacted(string $type): Check if current IP has reacted with this type
       - toggleReaction(string $type, string $ip, string $userAgent): Add or remove reaction
       - getUserReactionsAttribute(): Get array of reaction types for current IP
       
       Use request()->ip() and request()->userAgent() within trait methods.

    Follow Laravel polymorphic relationship conventions exactly.
  </action>
  <verify>
    php artisan migrate --pretend
    php artisan migrate
    php artisan tinker --execute="echo App\Models\Reaction::class;"
  </verify>
  <done>
    Migration runs successfully, Reaction model exists, Reactable trait is loadable
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply Reactable trait and update models</name>
  <files>
    app/Models/Post.php
    app/Models/Comment.php
  </files>
  <action>
    Apply the Reactable trait to models that can receive reactions:

    1. **Update Post model** (app/Models/Post.php):
       - Add `use App\Models\Traits\Reactable;` at top
       - Add `use Reactable;` in class body
       - No other changes needed - trait provides all functionality

    2. **Update Comment model** (app/Models/Comment.php):
       - Add `use App\Models\Traits\Reactable;` at top  
       - Add `use Reactable;` in class body
       - This allows reactions on comments as well (GitHub-style comment reactions)

    3. **Verify trait loading**:
       - Ensure both models have reactions() relationship
       - Ensure reaction_counts attribute is accessible

    The trait provides polymorphic functionality automatically.
  </action>
  <verify>
    php artisan tinker --execute="$p = new App\Models\Post; echo method_exists($p, 'reactions') ? 'yes' : 'no';"
    php artisan tinker --execute="$c = new App\Models\Comment; echo method_exists($c, 'reactions') ? 'yes' : 'no';"
  </verify>
  <done>
    Both Post and Comment models have reactions() relationship method via trait
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Reaction controller and Alpine.js component</name>
  <files>
    app/Http/Controllers/ReactionController.php
    resources/views/components/reaction-bar.blade.php
    resources/views/posts/show.blade.php
    routes/web.php
  </files>
  <action>
    Create the reaction API and interactive UI component:

    1. **ReactionController** (app/Http/Controllers/ReactionController.php):
       - Method: store(Request $request) - handles toggle logic
       - Validation: reactable_type (required, string, must use Reactable trait), 
                    reactable_id (required, integer, exists),
                    reaction_type (required, in:thumbs_up,heart,celebrate,rocket)
       - Resolve model class and verify it uses Reactable trait
       - Find or fail the reactable model
       - Toggle reaction via $reactable->toggleReaction($type, $ip, $userAgent)
       - Return JSON: ['reactions' => counts, 'user_reactions' => array of user's types]
       - Rate limit: 10 requests per minute per IP

    2. **Reaction bar component** (resources/views/components/reaction-bar.blade.php):
       Props: ['reactable' => null, 'types' => ['thumbs_up' => 'üëç', 'heart' => '‚ù§Ô∏è', 'celebrate' => 'üéâ', 'rocket' => 'üöÄ']]
       
       Alpine.js x-data object:
       - reactions: @json($reactable->reaction_counts)
       - userReactions: @json($reactable->getUserReactionsAttribute())
       - async toggle(type): fetch POST to /reactions with CSRF token, update local state from response
       
       Template:
       - Container with flex layout, border-t
       - Label "React:" with subtle text color
       - Loop through types creating buttons:
         * Each button: emoji + count (hidden if 0), hover scale effect
         * Active state: bg-love/20, ring-1 ring-love, text-love (Rose Pine theme)
         * Inactive state: bg-surface, hover:bg-overlay
         * Tooltip on hover with reaction name
         * @click="toggle('type')" handler
       - Use x-transition for smooth count changes

    3. **Add route** in web.php:
       Route::post('/reactions', [ReactionController::class, 'store'])->name('reactions.store')->middleware('throttle:reactions')

    4. **Add rate limiting** in RouteServiceProvider::boot():
       RateLimiter::for('reactions', fn($request) => Limit::perMinute(10)->by($request->ip()))

    5. **Integrate into post view**:
       Add <x-reaction-bar :reactable="$post" /> at bottom of posts/show.blade.php, after content

    Ensure CSRF token is available via {{ csrf_token() }} in component.
  </action>
  <verify>
    php artisan route:list | grep reactions
    grep -n "RateLimiter::for('reactions'" app/Providers/RouteServiceProvider.php
    grep -n "reaction-bar" resources/views/posts/show.blade.php
  </verify>
  <done>
    Reaction route exists with rate limiting, component created, integrated in post view, Alpine.js component functional
  </done>
</task>

</tasks>

<verification>
1. Test migrations: php artisan migrate:fresh --seed (if seeders exist)
2. Verify trait: php artisan tinker --execute="$p = App\Models\Post::first(); var_dump($p->reaction_counts);"
3. Check route: php artisan route:list | grep reaction
4. Verify component syntax: php blade:check (or manual blade compile test)
5. Test API manually: curl -X POST /reactions -d '{...}' -H 'Accept: application/json'
</verification>

<success_criteria>
- Reactions table created with polymorphic columns and unique constraint
- Reactable trait applied to Post and Comment models
- ReactionController with toggle endpoint returning JSON
- reaction-bar Blade component with Alpine.js interactivity
- Rate limiting active (10 reactions/minute per IP)
- Component visible on post pages
</success_criteria>

<output>
After completion, create `.planning/phases/06-reader-engagement/06-02-SUMMARY.md`
</output>
